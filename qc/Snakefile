import glob
import os

configfile: "config.yaml"

# detect samples based on sorted.bam, which is common between the ONT and Illumina pipeline
bam_suffix = ".sorted.bam"

def get_bam_pattern():
    return config.get("bam_pattern", "{data_root}/{sample}.sorted.bam")

def get_consensus_pattern():
    return config.get("consensus_pattern", "{data_root}/{sample}.primertrimmed.consensus.fa")

def get_qc_pattern():
    return config.get("qc_pattern", "{data_root}/{sample}.qc.csv")

def get_variants_pattern():
    return config.get("variants_pattern", "{data_root}/{sample}.variants.tsv")

def get_metadata_file(wildcards):
    return config.get("metadata", "")

def get_run_name():
    return config.get("run_name", "default")

def get_sample_names():

    # if defined in the config, use that
    # otherwise we try to auto-detect based on the bam names
    if "samples" in config:
        return config["samples"]

    # get all bams in the data directory based on the pattern
    # the bam files follow
    pattern = get_bam_pattern()

    # form a glob we can use to get the bam files for each sample
    gs = pattern.format(data_root=config["data_root"], sample="*")

    bams = glob.glob(gs)
    samples = list()
    for b in bams:
        f = os.path.basename(b)
        fields = f.split(".")
        if len(fields) > 4:
            continue
        samples.append(fields[0])

    return samples

def get_negative_control_samples():
    if "negative_control_samples" in config:
        return config["negative_control_samples"]
    else:
        return ""

def get_bam_for_sample(wildcards):
    bam_pattern = get_bam_pattern()
    return bam_pattern.format(data_root=config["data_root"], sample=wildcards.sample)

def get_variants_for_sample(wildcards):
    variants_pattern = get_variants_pattern()
    return variants_pattern.format(data_root=config["data_root"], sample=wildcards.sample)

def get_qc_for_sample(wildcards):
    qc_pattern = get_qc_pattern()
    return qc_pattern.format(data_root=config["data_root"], sample=wildcards.sample)

def get_consensus_for_sample(wildcards):
    consensus_pattern = get_consensus_pattern()
    return consensus_pattern.format(data_root=config["data_root"], sample=wildcards.sample)

def get_tree_consensus_sequences(wildcards):
    pattern = get_consensus_pattern()
    consensus_sequences = [pattern.format(data_root=config["data_root"], sample=s) for s in get_sample_names()]

    if "tree_include_consensus" in config:
        consensus_sequences.append(config["tree_include_consensus"])

    return consensus_sequences

def get_tree_plot_input(wildcards):

    input_list = ["qc_analysis/{prefix}_tree.nwk", "qc_analysis/{prefix}_alleles.tsv"]
    if "assign_lineages" in config and config["assign_lineages"]:
        input_list.append("lineages/{prefix}_lineage_report.csv")
    return input_list

def get_qc_sequencing_plots(wildcards):
    prefix = get_run_name()
    out = [ "plots/%s_amplicon_covered_fraction.pdf" % (prefix),
            "plots/%s_depth_by_position.pdf" % (prefix) ]

    # add plots that need Ct values
    if get_metadata_file(wildcards) != "":
        out.append("plots/%s_amplicon_depth_by_ct.pdf" % (prefix))
    return out

def get_qc_analysis_plots(wildcards):
    prefix = get_run_name()
    out = [ "plots/%s_tree_snps.pdf" % (prefix),
            "plots/%s_amplicon_coverage_heatmap.pdf" % (prefix) ]
    return out

def get_all_qc_analysis_plots(wildcards):
    prefix = get_run_name()
    out = [ "plots/%s_tree_snps.pdf" % (prefix),
            "plots/%s_amplicon_coverage_heatmap.pdf" % (prefix) ]
    if get_metadata_file(wildcards) != "":
        out.append("plots/%s_genome_completeness_by_ct.pdf" % (prefix))
    return out

def get_qc_summary(wildcards):
    prefix = get_run_name()
    return "qc_analysis/%s_summary_qc.tsv" % (prefix)

def get_qc_summary_metadata_opt(wildcards):
    metadata = get_metadata_file(wildcards)
    if metadata != "":
        return "--meta %s" % (metadata)
    else:
        return ""

#
# top-level rules
#
rule all_qc_sequencing:
    input:
        get_qc_sequencing_plots

rule all_qc_analysis:
    input:
        get_qc_analysis_plots

rule all_qc_analysis_plots:
    input:
        get_all_qc_analysis_plots

rule all_qc_summary:
    input:
        get_qc_summary

#
# generate coverage QC data using bedtools
#
rule make_amplicon_mean_coverage:
    input:
        get_bam_for_sample
    output:
        "qc_sequencing/{sample}.mean_coverage.bed"
    params:
        memory_per_thread="2G"
    threads: 1
    shell:
        "echo -e \"reference_name\tstart\tend\tamplicon_id\tpool\tstrand\tmean_coverage\" > {output};"
        "bedtools coverage -mean -a {config[amplicon_bed]} -b {input} >> {output}"

rule make_amplicon_coverage:
    input:
        get_bam_for_sample
    output:
        "qc_sequencing/{sample}.amplicon_coverage.bed"
    params:
        memory_per_thread="2G"
    threads: 1
    shell:
        "echo -e \"reference_name\tstart\tend\tamplicon_id\tpool\tstrand\tread_count\tcovered_bases\tamplicon_length\tfraction_covered\" > {output};"
        "bedtools coverage -a {config[amplicon_bed]} -b {input} >> {output}"

rule make_amplicon_per_base_coverage:
    input:
        get_bam_for_sample
    output:
        "qc_sequencing/{sample}.per_base_coverage.bed"
    params:
        memory_per_thread="2G"
    threads: 1
    shell:
        "echo -e \"reference_name\tstart\tend\tamplicon_id\tpool\tstrand\tposition\tdepth\" > {output};"
        "bedtools coverage -d -a {config[amplicon_bed]} -b {input} >> {output}"

# pysam's index_filename option is broken so we have
# to do some hacky symlinking to work around it
rule make_tmp_bam:
    input:
        get_bam_for_sample
    output:
        "tmp_bam/{sample}.bam"
    shell:
        "ln -s \"$(readlink -f {input})\" {output}"

rule make_bam_index:
    input:
        "{prefix}.bam"
    output:
        "{prefix}.bam.bai"
    shell:
        "samtools index {input}"

rule make_formatted_pileup:
    input:
        bam="tmp_bam/{sample}.bam",
        bai="tmp_bam/{sample}.bam.bai"
    output:
        "qc_sequencing/{sample}.fpileup.tsv"
    params:
        pileup_script = srcdir("format_pileup.py")
    shell:
        "python {params.pileup_script} --bam {input.bam} --reference {config[reference_genome]} > {output}"

rule merge_artic_qc:
    input:
        expand(config["data_root"] + "/{s}.qc.csv", s=get_sample_names())
    output:
        "qc_analysis/merged.qc.csv"
    shell:
        "cat {input} | awk 'NR == 1 || $0 !~ /qc_pass/' > {output}"

#
# Perform a multiple alignment with mafft and build a tree
#
rule make_merged_consensus:
    input:
        get_tree_consensus_sequences
    output:
        "qc_analysis/{prefix}_consensus.fasta"
    params:
        rename_script = srcdir("../tree/preprocess_consensus.py")
    shell:
        "python {params.rename_script} {input} > {output}"

rule make_msa:
    input:
        "qc_analysis/{prefix}_consensus.fasta"
    output:
        "qc_analysis/{prefix}_aligned.fasta"
    shell:
        "augur align --sequences {input} --reference-sequence {config[reference_genome]} --output {output} --fill-gaps"

rule make_tree_raw:
    input:
        "qc_analysis/{prefix}_aligned.fasta"
    output:
        "qc_analysis/{prefix}_tree_raw.nwk"
    shell:
        "augur tree --alignment {input} --output {output}"

rule make_tree_final:
    input:
        "qc_analysis/{prefix}_tree_raw.nwk"
    output:
        "qc_analysis/{prefix}_tree.nwk"
    shell:
        "nw_reroot {input} `head -1 {config[reference_genome]} | tr -d \">\"` > {output}"

rule make_alleles:
    input:
        "qc_analysis/{prefix}_aligned.fasta"
    output:
        "qc_analysis/{prefix}_alleles.tsv"
    params:
        alleles_script = srcdir("../tree/align2alleles.py")
    shell:
        "python {params.alleles_script} --reference-name MN908947.3 {input} > {output}"

rule make_lineage_assignments:
    input:
        "qc_analysis/{prefix}_consensus.fasta"
    output:
        "lineages/{prefix}_lineage_report.csv"
    threads: workflow.cores
    shell:
        "pangolin -t {threads} --outfile {output} {input}"
#
# QC plots
#
rule make_qc_plot_amplicon_coverage_heatmap:
    input:
        expand("qc_sequencing/{s}.amplicon_coverage.bed", s=get_sample_names())
    output:
        "plots/{prefix}_amplicon_coverage_heatmap.pdf"
    params:
        plot_script = srcdir("plot_amplicon_coverage_heatmap.R")
    shell:
        "Rscript {params.plot_script} --path qc_sequencing --output {output}"

rule make_qc_plot_depth_by_position:
    input:
        expand("qc_sequencing/{s}.per_base_coverage.bed", s=get_sample_names())
    output:
        "plots/{prefix}_depth_by_position.pdf"
    params:
        plot_script = srcdir("plot_qc_sequencing.R"),
        metadata=get_metadata_file
    shell:
        "Rscript {params.plot_script} depth_by_position {wildcards.prefix} {params.metadata}"

rule make_qc_plot_amplicon_depth_by_ct:
    input:
        files=expand("qc_sequencing/{s}.per_base_coverage.bed", s=get_sample_names()),
        metadata=get_metadata_file
    output:
        "plots/{prefix}_amplicon_depth_by_ct.pdf"
    params:
        plot_script = srcdir("plot_qc_sequencing.R")
    shell:
        "Rscript {params.plot_script} amplicon_depth_by_ct {wildcards.prefix} {input.metadata}"

rule make_qc_plot_fraction_covered_by_amplicon:
    input:
        expand("qc_sequencing/{s}.amplicon_coverage.bed", s=get_sample_names())
    output:
        "plots/{prefix}_amplicon_covered_fraction.pdf"
    params:
        plot_script = srcdir("plot_qc_sequencing.R")
    shell:
        "Rscript {params.plot_script} amplicon_covered_fraction {wildcards.prefix}"

rule make_qc_plot_alt_frequency:
    input:
        expand("qc_sequencing/{s}.fpileup.tsv", s=get_sample_names())
    output:
        expand("plots/alt_frequency.pdf")
    params:
        plot_script = srcdir("plot_qc_sequencing.R")
    shell:
        "Rscript {params.plot_script} alt_allele_frequency {wildcards.prefix}"

rule make_qc_genome_completeness_by_ct:
    input:
        qc="qc_analysis/merged.qc.csv",
        metadata=get_metadata_file
    output:
        "plots/{prefix}_genome_completeness_by_ct.pdf"
    params:
        plot_script = srcdir("plot_qc_sequencing.R")
    shell:
        "Rscript {params.plot_script} genome_completeness_by_ct {wildcards.prefix} {input.metadata}"

rule make_qc_tree_snps:
    input: get_tree_plot_input
    output:
        "plots/{prefix}_tree_snps.pdf"
    params:
        plot_script = srcdir("../tree/plot_tree_snps.R")
    shell:
        "Rscript {params.plot_script} {output} {input}"

# generate the summary QC metrics
rule make_sample_qc_summary:
    input:
        samplecoverage="qc_sequencing/{sample}.per_base_coverage.bed",
        # samplevariants="{config[data_root]}/{sample}.variants.tsv",
        samplevariants=get_variants_for_sample,
        # sampleqc="{config[data_root]}/{sample}.qc.csv",
        sampleqc=get_qc_for_sample,
        # samplefasta="{config[data_root]}/{sample}.primertrimmed.consensus.fa"
        samplefasta=get_consensus_for_sample
    output:
        "qc_analysis/{sample}.summary.qc.tsv"
    params:
        py_script="get_qc_summary.py",
        metadata_opt=get_qc_summary_metadata_opt
    shell:
        "{params.py_script} --variants {input.samplevariants} --qc {input.sampleqc} --coverage {input.samplecoverage} {params.metadata_opt} --indel --reference {config[reference_genome]} --fasta {input.samplefasta} > {output}"

rule make_full_qc_summary:
    input:
        expand("qc_analysis/{s}.summary.qc.tsv", s=get_sample_names())
    output:
        "qc_analysis/{prefix}_summary_qc.tsv"
    params:
        py_script="collect_qc_summary.py"
    shell:
        "{params.py_script} --path qc_analysis > {output}"

rule make_negative_control_report:
    input:
        expand("qc_sequencing/{s}.per_base_coverage.bed", s=get_negative_control_samples())
    output:
        "qc_sequencing/{prefix}_negative_control_report.tsv"
    params:
        script=srcdir("negative_control_check.py")
    shell:
        "python {params.script} {input} > {output}"

rule make_fpileups_fofn:
    input:
        expand("qc_sequencing/{s}.fpileup.tsv", s=get_sample_names())
    output:
        "qc_sequence/{prefix}_fpileups.fofn",
    shell:
        'echo {input} | tr " " "\\n" > {output}'

rule make_mixture_report:
    input:
        fpileups="qc_sequence/{prefix}_fpileups.fofn",
        alleles="qc_analysis/{prefix}_alleles.tsv"
    output:
        "qc_analysis/{prefix}_mixture_report.tsv"
    params:
        script=srcdir("mixture_check.py")
    shell:
        "python {params.script} --fpileup {input.fpileups} --alleles {input.alleles} > {output}"
